---
# 추가 컨트롤 플레인 노드 업그레이드 태스크

- name: "추가 마스터 노드 업그레이드 시작"
  debug:
    msg: "추가 컨트롤 플레인 노드 {{ inventory_hostname }}의 업그레이드를 시작합니다"

# 첫 번째 마스터 노드가 업그레이드 완료될 때까지 대기
- name: "첫 번째 마스터 노드 업그레이드 완료 대기"
  wait_for:
    timeout: "{{ k8s_upgrade_timeout }}"
  delegate_to: "{{ groups['k8s_masters'][0] | default(groups['all'][0]) }}"
  run_once: true

- name: "API 서버 연결 확인"
  uri:
    url: "https://{{ hostvars[groups['k8s_masters'][0] | default(groups['all'][0])]['ansible_default_ipv4']['address'] }}:6443/version"
    method: GET
    validate_certs: false
    status_code: 200
  retries: 30
  delay: 10
  register: api_check

# 노드 드레인
- name: "노드 드레인"
  shell: |
    kubectl drain {{ inventory_hostname }} \
      --ignore-daemonsets \
      --delete-emptydir-data \
      --force \
      --timeout={{ k8s_upgrade_drain_timeout }}s
  delegate_to: "{{ groups['k8s_masters'][0] | default(groups['all'][0]) }}"
  when: not k8s_upgrade_skip_drain
  ignore_errors: true

# kubeadm, kubelet, kubectl 업그레이드
- name: "패키지 관리자를 통한 업그레이드"
  include_tasks: install_packages.yml
  when: k8s_detected_package_manager != 'binary'

- name: "바이너리를 통한 업그레이드"
  include_tasks: install_binaries.yml
  when: k8s_detected_package_manager == 'binary'

# kubeadm 업그레이드
- name: "kubeadm 업그레이드 실행"
  shell: |
    kubeadm upgrade node
  register: kubeadm_upgrade_result
  failed_when: kubeadm_upgrade_result.rc != 0

- name: "kubeadm 업그레이드 결과 확인"
  debug:
    var: kubeadm_upgrade_result.stdout_lines

# kubelet 재시작
- name: "kubelet 서비스 재시작"
  systemd:
    name: kubelet
    state: restarted
    daemon_reload: true
  when: k8s_restart_services

# 노드 언코든
- name: "노드 언코든"
  shell: |
    kubectl uncordon {{ inventory_hostname }}
  delegate_to: "{{ groups['k8s_masters'][0] | default(groups['all'][0]) }}"
  when: not k8s_upgrade_skip_cordon

# 노드 상태 확인
- name: "노드 Ready 상태 확인"
  shell: |
    kubectl get node {{ inventory_hostname }} -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}'
  register: node_status
  until: node_status.stdout == "True"
  retries: "{{ k8s_health_check_retries }}"
  delay: "{{ k8s_health_check_delay }}"
  delegate_to: "{{ groups['k8s_masters'][0] | default(groups['all'][0]) }}"

# 컨트롤 플레인 컴포넌트 상태 확인
- name: "컨트롤 플레인 파드 상태 확인"
  shell: |
    kubectl get pods -n kube-system \
      -l tier=control-plane \
      --field-selector spec.nodeName={{ inventory_hostname }} \
      -o jsonpath='{.items[*].status.phase}' | grep -v Running | wc -l
  register: control_plane_pods
  until: control_plane_pods.stdout | int == 0
  retries: "{{ k8s_health_check_retries }}"
  delay: "{{ k8s_health_check_delay }}"
  delegate_to: "{{ groups['k8s_masters'][0] | default(groups['all'][0]) }}"

# etcd 멤버 상태 확인
- name: "etcd 멤버 상태 확인"
  shell: |
    kubectl exec -n kube-system etcd-{{ inventory_hostname }} -- \
      etcdctl --endpoints=https://127.0.0.1:2379 \
      --cacert=/etc/kubernetes/pki/etcd/ca.crt \
      --cert=/etc/kubernetes/pki/etcd/server.crt \
      --key=/etc/kubernetes/pki/etcd/server.key \
      member list
  register: etcd_status
  delegate_to: "{{ groups['k8s_masters'][0] | default(groups['all'][0]) }}"
  ignore_errors: true

- name: "etcd 상태 결과"
  debug:
    var: etcd_status.stdout_lines
  when: etcd_status is defined

# 버전 확인
- name: "업그레이드된 버전 확인"
  shell: |
    kubelet --version | awk '{print $2}' | sed 's/v//'
  register: upgraded_version

- name: "업그레이드 완료 확인"
  debug:
    msg: "{{ inventory_hostname }} 컨트롤 플레인 노드가 성공적으로 {{ upgraded_version.stdout }}로 업그레이드되었습니다"

- name: "추가 마스터 노드 업그레이드 완료"
  debug:
    msg: "추가 컨트롤 플레인 노드 {{ inventory_hostname }}의 업그레이드가 완료되었습니다" 